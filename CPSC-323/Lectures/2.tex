\section{August 31, 2018}

\subsection*{Linux File System}

The Linux file system has a user interface which consists of a hierarchical name structure based in a root directory, usually called \texttt{/} or \texttt{root}. There are two kinds of names, \emph{absolute} and \emph{relative}. Absolute names, like \texttt{/c/cs323/Hwk1/...}, always begin with a \texttt{/} in the root directory, and are often quite long. Relative names begin with some character other than \texttt{/}, and is implicitly prefixed by the name of the current working directory. This directory can change based on how you're using the computer. These make names much shorter. We can change the current working directory using the \texttt{cd} bash command, or the \texttt{chdir()} syscall in C.

A \emph{file} is a stream of bytes with \emph{no} implied formatting. Each file has associated with it a unique number called an \emph{inode number} which is an index into an array of structs. There is one array per file system. The inode structs have several fields, including
\begin{itemize}
\item the \texttt{length} of the file in bytes;
\item the \texttt{type} of the file/directory/symbolic links/devices/named pipes/etc;
\item the \texttt{userid} of the owner of the file;
\item the \texttt{groupid} of the file group;
\item \texttt{protection} bits, essentially the read/write/exec permissions --- there are separate protection bits for the owner, group, and everyone else;
\item \texttt{timestamps} for the access, create, and modify times of the file;
\item the number of \texttt{hard links} to the file;
\item a block of pointers to the the disk block.
\end{itemize}
Notice that there is no name! In Linux, files don't really have absolute names. Instead, we assign names to files using \emph{directories}. A directory is a special file containing ordered pairs of an inode number and a name which doesn't contain a slash\footnote{slashes are used to separate directories}:
\[ \texttt{(inode \#, name)} \]
These pairs are called \emph{hard links}. In an inode struct, if the number of hard links ever reaches zero, then the file is ``deleted.'' This gives the relation 
\[ \texttt{(inode \#, name)} \in \texttt{dir} \iff \text{\texttt{dir/name} is a valid name for the file}. \]
The operating system is responsible for updating the number of hard links for every file. All of this really means that there isn't a one-to-one correspondence between inodes (files) and names.

In every directory, there are two special files: \texttt{.}, which is the current directory, and \texttt{..}, which is the parent directory. These let us walk around the file system.

\subsection*{Links}

We know that a hard link is just a pair of an inode and a local file name. The \texttt{rm} command removes the hard link from the directory and decrements the inode's hard link count. The command \texttt{ln} does the opposite. These are mirrored by the syscalls \texttt{link()} and \texttt{unlink()}.

There are also \emph{soft links}. The contents of a soft link inode is a string containing a semantically valid file name. They are created by the \texttt{ln -s} command or the \texttt{symlink()} syscall. As an example, on the Zoo $\texttt{ln -l /c}$ reveals that the \texttt{/c} directory is actually a soft link to the directory \texttt{/home/classes}.

\subsection*{Directories}

If you want to create a directory, use the \texttt{mkdir} command or the \texttt{mkdir()} syscall. To remove one, issue the \texttt{rmdir} command or the \texttt{rmdir()} syscall. To read a directory, use the \texttt{ls} command or several related commands, as in \texttt{opendir()}, \texttt{readdir()} $\times\, n$, \texttt{closedir()}.

\subsection*{Machine Arithmetic, Round Two}

[fill in an explanation of the fast adder from last lecture, or maybe just put it in Lec 1.]

The time to add two $m$ bit numbers is $\mathrm{Time}(m) = \mathrm{T}(m/2) + \mathcal{O}(1)$, where we have logarithmically many called for $\mathrm{T}(m/2)$ to do all of the calculations, so our total time is $\mathcal{O}(\log_2 m)$. This is great! That's the best we could hope for!

Unfornately, our space is $\mathrm{Space}(m) = 3 \cdot \mathrm{S}(m/2) + \mathcal{O}(m)$, since we have three distinct adders for each $m/2$ bit numbers, which is actually $\mathcal{O}(m^{k\log_2 3})$ for $k$ repeated additions. Since $k\log_2 3 > 1$, this means that our space is growing superlinearly. This isn't so great.

\subsection*{Carry Look-Ahead Adder}

Let $c_k$ be the carry-in bit for the $k$ bit position, which is the carry-out for the $k-1$ bit position. Then $c_0 = 0$ is the initial carry in and $c_m$ is the overflow bit. The following relation is true
\[ c_{k+1} = (a_k \land b_k) \lor (a_k \lor b_k) \land c_k. \]
Let $g_k = a_k \land b_k$ be the generator, and let $p_k = a_k \lor b_k$ be the propogator. Then we can write this more generally as 
\[ c_k = g_k \lor p_k \land c_k. \]
As it turns out, we can calculate all $g_k$ and $p_k$ in parallel in only a single gate delay. This means that we can compute all carries in \[\underbrace{1}_{pkgk} + \underbrace{2m}_{g_k \lor p_k \land c_k} +\underbrace{1}_{compute sk} \quad \text{steps.} \]
Can we do any better?

\subsection*{Recursive Doubling}

Suppose I want to calculate $c_{2\ell + 2} = g_{2\ell + 1} \lor p_{2\ell + 1} \land c_{2\ell + 1}$. Notice that $c_{2\ell + 1} = g_{2\ell} \lor p_{2\ell} \land c_{2\ell}$. If we treat this logic like arithmetic, we can simplify the above into
\begin{align*}
c_{2\ell + 2} &= g_{2\ell + 1} \lor p_{2\ell + 1} \land c_{2\ell + 1} \\
&= (g_{2\ell + 1} \lor p_{2\ell + 1} \land g_{2\ell}) \lor (p_{2\ell} \land p_{2\ell+1}  \land c_{2\ell}),
\end{align*}
which can be computed in $6+m = \mathcal{O}(m)$ steps. \note{fix this section up a lot}
% !TEX root = ../notes.tex

\section{January 15, 2019}

\subsection{Administrata}

Started off with basic administrata. Differences between 365 and 366 (pretty much the same but with proofs and a bit more sophisticated material). You probably know what you're getting into. The no collaboaration policy is terrible :(

We'll cover the following topics,
\begin{multicols}{2}
\begin{enumerate}
\item Greedy Algorithms
\item Dynamic Programming
\item Divide and Conquer
\item Network Flow
\item Linear Programming
\item NP and NP-completeness
\item Approximation Algorithms
\item \emph{Heuristics}
\item \emph{Randomized Algorithms}
\item \emph{Online Algorithms}
\end{enumerate}
\end{multicols}
where the italicized items are things we will cover if time permits.

\subsection{Greedy Algorithms}

A greedy algorithm is one which locally make some optimal choice and stick with it. The important part is defining what ``optimal'' means. This involves choosing criteria and proving correctness with it.

\begin{problem}[Interval Scheduling]
Say you have a conference room with many requests to use it, and you want to satisfy as many of these possibly overlapping requests as possible. The input to this problem is a list of intervals $\{(s_1,f_1) , \cdots, (s_n,f_n)\}$ where the $i$\textsuperscript{th} interval starts at $s_i$ and ends at $f_i$, so clearly $s_i < f_i$. Intervals $i$ and $j$ overlap if $s_j > f_i$.
\end{problem}

\begin{algorithm}
\begin{algorithmic}[]

\Procedure{Greedy}{$C$}

\State $A \gets \emptyset$
\State Sort $C$
\For{$c \in C$}
	\If{$c$ has no conflicts in $A$} \State $A = A \cup c$ \EndIf
\EndFor
\EndProcedure

\end{algorithmic}
\end{algorithm}

The most important question here is ``how do we order the intervals?'' One way we might do this is by ordering each by the start time, but then we are penalized if there is one really long interval that starts first. So instead, we could sort the intervals based on the duration. However, if we have a short interval which overlaps two longer intervals, so this is also problematic. We could sort it based on the fewest number of conflicts, but this is also problematic if we have identical overlapping intervals. 

The best option is to sort the intervals based on when the \emph{end}. This is intuitive since we want to free up our resource as quickly as possible.

\begin{problem}[What is the running time of this algorithm?]
There are three main steps: the time to sort the list of intervals, which can easily be done in $O(n\log n)$ time; the comparison to other intervals in $A$, which can be done in $O(1)$ time since the list is already ordered and if an interval conflicts with any already in our ansewr it must conflict with the last one added since for all $j > i$ we know that $f_i \leq f_j$; and adding the interval to the list, which is constant time as well. We do these last two steps $n$ times, so the total run time is $O(n)$ for these parts. Then the whole algorithm runs in $O(n \log n)$ time.
\end{problem}

\begin{problem}[How do we know this algorithm is correct?]
Suppose that the intervals are already sorted based on the finish time. Then $f_1 \leq f_2 \leq \cdots \leq f_n$.

\begin{theorem}
The algorithm outputs a maximal set of non-overlapping intervals.
\end{theorem} \vspace{1ex}

\noindent You can try to prove that this algorithm find the optimal answer, but it's quite easy to find cases where optimal solution may not be unique (see the identical overlapping intervals from previous). Instead, we can argue that this algorithm is better than any other by showing that it is ahead of any other algorithm.

\begin{theorem}
Let $A = \{a_1, \cdots, a_k\}$ where $a_i < a_j$ by finish time be the output of our algorithm, and let $B = \{b_1, \cdots, b_\ell\}$ be any sorted other list of non-overlapping intervals (the output of some other algorithm). Then $a_i \leq b_i$ for all $i$.
\end{theorem}

\begin{proof}[Proof our algorithm stays ahead]
We proceed by induction on $j \in \{1, \cdots, \min\{k,\ell\}\}$.
We know that $a_1$ finished first, so $b_1$ must finish no sooner than $a_1$, so the claim is true for $j = 1$. For the inductive step, assume that the claim is true for some $j$. Then $f_{a_j} \leq f_{b_j} \leq s_{b_{j+1}}$. Then $b_{j+1}$ does not overlap with any interval $a_1, \cdots, a_j$, so our algorithm could add $b_{j+1}$ to $A$ (there may be a strictly better choice for us, but we know that we \emph{can} add it). Then $f_{a_{j+1}} \leq f_{b_{j+1}}$. Then by induction the claim is true for all $j$.
\end{proof}

\begin{proof}[Proof of correctness]
By way of contradiction, assume that $k < \ell$. By our previous proof, we know that $a_i < b_i$ for all $i$. Then $f_{a_1} \leq a_{a_2} \leq \cdots \leq f_{a_{k}} \leq f_{b_k} \leq s_{b_{k+1}}$. This is a contradiction, since our algorithm would have added to $b_{k+1}$ to $A$.
\end{proof}
\end{problem}

\begin{problem}
What if we tweak the problem to have a payoff associated with it and we want to maximize the payoff? Our greedy algorithm (in fact, \emph{any} greedy algorithm) won't work (but we do know one which uses dynamic programming).
\end{problem}